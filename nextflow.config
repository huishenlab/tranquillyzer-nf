/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Shared parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

includeConfig 'conf/params.config'

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Pipeline manifest
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

manifest {
  name            = 'AyushSemwal/tranquillyzer-nf'
  homePage        = 'https://github.com/AyushSemwal/tranquillyzer-nf'
  description     = 'Nextflow DSL2 pipeline for long-read RNA-seq data with Tranquillyzer'
  mainScript      = 'main.nf'
  version         = '0.2.0'
  nextflowVersion = '>=23.10.0'
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Helpers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

def _s(x) { x == null ? '' : x.toString() }
def _t(x) { _s(x).trim() }

def _binds() {
  (params.container_binds ?: [])
    .collect { "--bind ${it}" }
    .join(' ')
}

/**
 * Normalize container image ref for the selected engine:
 * - docker: DO NOT allow docker:// prefix (Docker errors with "invalid reference format")
 * - apptainer/singularity: prefix docker:// for plain docker image names
 */
def _img(String image) {
  if (!image) return image

  // If Docker is enabled, NEVER pass docker:// to the Docker runtime
  if (docker.enabled && image.startsWith('docker://')) {
    return image.replaceFirst('^docker://', '')
  }

  def engine = _t(params.container_engine).toLowerCase()

  // For apptainer/singularity, prefix docker:// for plain docker image names
  if ((engine == 'apptainer' || engine == 'singularity') &&
      !image.contains('://') &&
      !image.endsWith('.sif')) {
    return "docker://${image}"
  }

  return image
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Environment (GPU libs for apptainer/singularity if provided)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

env {
  APPTAINERENV_LD_LIBRARY_PATH = _t(params.cuda_lib_dir)
    ? "${_t(params.cuda_lib_dir)}:${System.getenv('APPTAINERENV_LD_LIBRARY_PATH') ?: ''}"
    : null

  LD_LIBRARY_PATH = _t(params.cuda_lib_dir)
    ? "${_t(params.cuda_lib_dir)}:${System.getenv('LD_LIBRARY_PATH') ?: ''}"
    : null
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Global execution defaults
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

process {
  // Default container used by most processes (engine-aware normalization)
  container = _img(_t(params.container_trq))

  errorStrategy = 'terminate'
  maxRetries    = 1

  // Helpful task tag
  tag = { "${task.process} (${task.attempt})" }
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Executor selection (default)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

process.executor = (params.executor ?: 'local')

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Container engines (single source of truth)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

def _engine = _t(params.container_engine).toLowerCase()

docker.enabled      = (_engine == 'docker')
singularity.enabled = (_engine == 'singularity')
apptainer.enabled   = (_engine == 'apptainer')

// Guard: do not allow multiple engines on
def _enabled_engines = [docker.enabled, singularity.enabled, apptainer.enabled].count { it }
if ( _enabled_engines > 1 ) {
  throw new IllegalArgumentException("Cannot enable more than one container engine -- Choose either one of: docker, singularity, apptainer")
}

if (singularity.enabled) {
  singularity.autoMounts = true
  singularity.cacheDir   = params.image_dir
  singularity.runOptions = _binds()
}
if (apptainer.enabled) {
  apptainer.autoMounts = true
  apptainer.cacheDir   = params.image_dir
  apptainer.runOptions = _binds()
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Executor-level throttling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

executor {
  queueSize = params.queueSize ?: 10
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SLURM defaults (only apply when executor == slurm)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

if (process.executor == 'slurm') {
  process.queue  = params.slurm_queue ?: null
  process.time   = params.slurm_time  ?: '24h'
  process.cpus   = params.slurm_cpus  ?: 8
  process.memory = params.slurm_mem   ?: null
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Process-level behavior
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

process {

  /*
   * Run publish/load steps on the host to avoid container mount/symlink issues.
   */
  withLabel: 'host' {
    container        = null
    containerOptions = ''
    clusterOptions   = ''
  }

  /*
   * FeatureCounts: stable selector via label 'subread'
   */
  withLabel: 'subread' {
    container        = _img(_t(params.container_subread))
    containerOptions = _t(params.container_extra_opts)
    clusterOptions   = ''
  }

  /*
   * CPU-labeled processes: no GPU flags
   */
  withLabel: 'cpu' {
    containerOptions = _t(params.container_extra_opts)
  }

  /*
   * GPU-labeled processes:
   * - Apply container runtime GPU flags only when enable_gpu=true
   * - Optionally apply SLURM GPU request flags (clusterOptions)
   */
  withLabel: 'gpu' {
    def extra = _t(params.container_extra_opts)
    def gpuEnabled = (params.enable_gpu == true)

    def gpuPrefix = ''
    if (gpuEnabled) {
      if (docker.enabled) {
        gpuPrefix = '--gpus all'
      } else if (singularity.enabled || apptainer.enabled) {
        gpuPrefix = '--nv'
      }
    }

    containerOptions = gpuEnabled
      ? "${gpuPrefix} ${extra}".trim()
      : extra

    clusterOptions = (process.executor == 'slurm' && gpuEnabled && _t(params.slurm_gpu_opts))
      ? _t(params.slurm_gpu_opts)
      : ''
  }
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Profiles (infra selection)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

profiles {

  standard {
    process.executor = 'local'
  }

  local {
    process.executor = 'local'
  }

  slurm {
    process.executor = 'slurm'
    process.queue    = params.slurm_queue ?: null
    process.time     = params.slurm_time  ?: '24h'
    process.cpus     = params.slurm_cpus  ?: 8
    process.memory   = params.slurm_mem   ?: null
  }

  docker {
    params.container_engine = 'docker'
    docker.enabled      = true
    apptainer.enabled   = false
    singularity.enabled = false
  }

  apptainer {
    params.container_engine = 'apptainer'
    docker.enabled      = false
    apptainer.enabled   = true
    singularity.enabled = false

    apptainer.autoMounts = true
    apptainer.cacheDir   = params.image_dir
    apptainer.runOptions = _binds()
  }

  singularity {
    params.container_engine = 'singularity'
    docker.enabled      = false
    apptainer.enabled   = false
    singularity.enabled = true

    apptainer.autoMounts = true
    singularity.cacheDir    = params.image_dir
    singularity.runOptions  = _binds()
  }

  awsbatch {
    process.executor = 'awsbatch'
    aws.region       = params.aws_region ?: null
    process.queue    = params.aws_queue  ?: null
    workDir          = params.workDir ?: workDir
  }

  google {
    process.executor = 'google-lifesciences'
    google.project   = params.gcp_project ?: null
    google.location  = params.gcp_region  ?: null
    workDir          = params.workDir ?: workDir
  }

  azurebatch {
    process.executor = 'azurebatch'
    azure.batch.accountName = params.azure_account ?: null
    azure.batch.location    = params.azure_region  ?: null
    workDir                 = params.workDir ?: workDir
  }

  kubernetes {
    process.executor = 'kubernetes'
    k8s.namespace    = params.k8s_namespace ?: 'default'
  }
}

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Reports (written to outdir/pipeline_info)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/

trace {
  enabled   = true
  file      = "${params.outdir}/pipeline_info/execution_trace.tsv"
  sep       = '\t'
  fields    = 'tag,task_id,process,status,exit,submit,start,complete,realtime,%cpu,cpus,peak_rss,peak_vmem'
  overwrite = true
}

report {
  enabled   = true
  file      = "${params.outdir}/pipeline_info/execution_report.html"
  overwrite = true
}

timeline {
  enabled   = true
  file      = "${params.outdir}/pipeline_info/execution_timeline.html"
  overwrite = true
}

dag {
  enabled   = true
  file      = "${params.outdir}/pipeline_info/pipeline_dag.svg"
  overwrite = true
}